

---

### **音视频开发学习路径**

### **阶段零：通用后端基础 (你已规划)**

在你开始音视频之旅前，**必须**完成我们之前规划的第一、第二阶段，即：
1.  **精通数据结构与算法。**
2.  **精通C++和Linux开发环境。**
3.  **深刻理解操作系统（特别是进程、线程、内存、I/O）。**
4.  **深刻理解网络原理（TCP/UDP），并亲手实现过基于`epoll`的Reactor。**

**没有这个基础，直接进入音视频领域，无异于不会走路就想跑，你会寸步难行。**

---

### **第一阶段：音视频基础理论 - “学习音视频世界的语言”**

这个阶段的目标是：理解音视频数据是如何被采集、编码、封装和传输的。你需要啃一些枯燥但极其重要的理论。

#### **核心书籍**

1.  **《FFmpeg从入门到精通》** (作者：刘歧)
    *   **定位**：**FFmpeg的“新华字典”和“实战手册”**。
    *   **为什么是它？** FFmpeg是音视频处理的“原子操作”。这本书不是教你FFmpeg的C++ API，而是教你**如何使用FFmpeg的命令行工具**。这个过程极其重要，因为它能让你**用最快的方式，亲手实践**各种编码（H.264/H.265）、封装（MP4/TS/FLV）、滤镜、协议（RTMP/HLS）的操作，从而建立起对音视频处理流程的**直观概念**。
    *   **学习方法**：**把它当作一本实验手册**。书中的每一条命令，都值得你在自己的VPS上亲手敲一遍，观察输入和输出的变化。

2.  **《WebRTC权威指南（第3版）》** (WebRTC: APIs and RTC Infrastructure for Real-Time Communication)
    *   **定位**：**实时通信（RTC）领域的“圣经”**。
    *   **为什么是它？** 即使你暂时不开发WebRTC应用，这本书也极其有价值。因为它系统性地讲解了构建一个**低延迟**实时通信系统所需的全套技术栈，这些技术在所有RTC应用中都是通用的。
    *   **你需要重点学习的“概念”**：
        *   **信令 (Signaling)**：客户端之间是如何“发现”对方并建立连接的。
        *   **NAT穿透**：STUN/TURN/ICE协议是如何解决设备在内网无法直接通信的问题的。
        *   **媒体协商**：SDP协议是如何描述和协商双方的音视频能力的。
        *   **RTP/RTCP协议**：在UDP之上，是如何打包、传输、控制音视频流的。
        *   **拥塞控制与带宽估计**：在不稳定的互联网上，如何动态调整发送码率，避免卡顿。

#### **核心在线教程/文档 (必读)**

1.  **雷霄骅的博客 (CSDN)**
    *   **定位**：**已故的音视频领域“盗火者”，无数人的启蒙导师**。
    *   **为什么是它？** 雷神用最通俗易懂的语言，写下了一系列关于FFmpeg API使用、视音频编解码、流媒体协议的入门文章。虽然内容有些年头，但其对核心概念的讲解，至今无人能出其右。
    *   **学习方法**：搜索“雷霄骅 ffmpeg”，找到他的博客专栏，**从第一篇开始，一篇一篇地看，一篇一篇地跟着做**。比如《最简单的基于FFmpeg的视频播放器》，跟着他用几十行代码就能写出一个播放器，会给你巨大的成就感。

2.  **RFC文档 (当你需要最权威的定义时)**
    *   当你想了解某个协议的最精确细节时，就需要去读它的“法律文本”——RFC文档。
    *   **示例**：
        *   RTP: RFC 3550
        *   RTMP: Adobe官方规范 (虽然不是RFC，但也是权威文档)

---

### **第二阶段：源码实战 - “在战争中学习战争”**

当你具备了基础理论后，就必须一头扎进真实世界的项目中。**阅读和二次开发优秀的开源媒体服务器，是成为音视频专家的唯一途径。**

#### **核心开源项目 (主攻一个，参考其他)**

1.  **SRS (Simple Realtime Server) - (主攻项目)**
    *   **语言**：C++
    *   **定位**：**学习直播和WebRTC服务器的“黄埔军校”**。
    *   **为什么主攻它？**
        *   **文档极其完善**：拥有海量的中文Wiki、分析文章和配套书籍，几乎把所有设计细节都掰开揉碎了讲给你听。
        *   **代码清晰，注释详尽**：代码风格虽然是传统的C++03，但逻辑清晰，非常适合初学者阅读和理解。
        *   **功能聚焦**：主要围绕直播（RTMP/HLS/HTTP-FLV）和WebRTC，让你能集中精力攻克核心领域。
        *   **社区活跃**：遇到问题很容易找到人讨论。
    *   **学习路径**：
        1.  **编译运行**：先在你的VPS上把它成功编译并运行起来。
        2.  **使用**：用OBS向它推流，再用VLC从它拉流，把整个流程跑通。
        3.  **读文档**：通读它的Wiki，特别是“WIKI: ANALYZE”部分，理解它的架构、进程模型、协程模型。
        4.  **读源码**：在你已经具备了UNP和Reactor基础之上，从`srs_app_rtmp.cpp`或`srs_app_server.cpp`入手，用GDB单步跟踪一个RTMP连接的处理过程。

2.  **ZLMediaKit - (进阶参考)**
    *   **语言**：C++11
    *   **定位**：**代码更现代、性能极高、协议支持更全面的媒体服务器框架**。
    *   **为什么参考它？**
        *   **现代C++实践**：大量使用智能指针、Lambda、`std::function`，是现代C++在高性能服务器中应用的典范。
        *   **代码精悍**：代码量相对SRS小得多，架构设计非常精巧。
    *   **学习方法**：在你读懂SRS之后，再来看ZLMediaKit，对比两者在线程模型、API设计上的异同，会非常有启发。

#### **客户端 (如果你对客户端也感兴趣)**

*   **OBS Studio**：研究它是如何使用FFmpeg的库进行编码和推流的，以及它是如何通过底层图形API进行高性能采集的。
*   **VLC Media Player**：研究它的模块化设计，以及`libVLC`这个核心库是如何构建的。
*   **IJKPlayer** (B站开源的播放器内核)：如果你对移动端播放器感兴趣，这是基于FFmpeg的业界标杆。

---
